# Standard libraries
import math
import random
import os

# Third party libraries
import numpy as np
import matplotlib.pyplot as plt
import scipy as sp

# Local imports
# from environment_properties import ENV
time_mars_day = 88775 #Average Martian day duration [sec]
from solar_flux_analysis import get_avg_solar_flux
from power_load_profile import get_average_power_mission
from solar_flux_analysis import plot_solar_flux_daily


#Define inputs
design_charge_time = time_mars_day #Design EPS for 1 mission per day
solar_cell_efficiency = 0.35 #Quadruple junction solar cell efficieny
design_incidence_angle = 15 #Design to charge on a 15 degree slope
average_solar_flux = 131.14 #Design for average yearly solar flux [W/m^2]
solar_cell_degradation_rate = 0.02 #Degradation rate [% per year]
mission_lifetime = 2 #Duration of primary mission [years]
average_power_generation = get_average_power_mission()
print('required_average_power_generation', average_power_generation)

#Calculate required power generation at BOL conditions
power_generation_EOL = average_power_generation
power_generation_BOL = power_generation_EOL / (1-solar_cell_degradation_rate)**(mission_lifetime)


#Calculate required solar array area
design_solar_flux = average_solar_flux * np.cos(np.radians(design_incidence_angle))
array_area = power_generation_BOL / (design_solar_flux * solar_cell_efficiency)
print('required_solar_array_area [m^2]', array_area)


#Sanity check: calculate time to charge generate mission energy at EOL conditions, using yearly average flux
# mission_energy = 10157500 #Total mission energy (over 1 martian day) [J]
# power_generated = (1-solar_cell_degradation_rate)**(mission_lifetime) * average_solar_flux * np.cos(np.radians(design_incidence_angle)) * solar_cell_efficiency * array_area
# time_to_charge = mission_energy / power_generated
# print('time_to_charge [hours]', time_to_charge/3600)


filepath_daily_flux = os.path.join('PowerTools/data', 'solar_flux_160deg.txt')
solar_flux_160_martian_day = plot_solar_flux_daily(filepath_daily_flux) #Solar flux corresponding to day 160 of the year, as a list (one entry per second) [W/m^2]

#Interpolate data to create a list of solar fluxes at every second
data_points = solar_flux_160_martian_day[1]

original_length = len(data_points)
desired_length = 88772

original_indices = np.linspace(0, original_length - 1, original_length)
desired_indices = np.linspace(0, original_length - 1, desired_length)

interpolated_solar_flux_160_martian_day = np.interp(desired_indices, original_indices, data_points)

time_series=np.linspace(0,88772,88772)

#Compute power generation profile for Martian day 160
power_generation_profile = interpolated_solar_flux_160_martian_day * solar_cell_efficiency * array_area * (1-solar_cell_degradation_rate)**mission_lifetime * np.cos(np.radians(design_incidence_angle)) #Power generated by solar array for an average martian day (day 160)



#Define functions for outputs that need to be used in other files
def get_solar_array_area():
    array_area = power_generation_BOL / (design_solar_flux * solar_cell_efficiency)
    return array_area

def get_power_generation_profile():
    power_generation_profile = interpolated_solar_flux_160_martian_day * solar_cell_efficiency * array_area * (1-solar_cell_degradation_rate)**mission_lifetime * np.cos(np.radians(design_incidence_angle)) 
    return power_generation_profile